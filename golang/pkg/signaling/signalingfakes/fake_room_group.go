// Code generated by counterfeiter. DO NOT EDIT.
package signalingfakes

import (
	"sync"

	"github.com/ryanrolds/club/pkg/signaling"
)

type FakeRoomGroup struct {
	AddMemberStub        func(signaling.GroupMember)
	addMemberMutex       sync.RWMutex
	addMemberArgsForCall []struct {
		arg1 signaling.GroupMember
	}
	BroadcastStub        func(signaling.Message) error
	broadcastMutex       sync.RWMutex
	broadcastArgsForCall []struct {
		arg1 signaling.Message
	}
	broadcastReturns struct {
		result1 error
	}
	broadcastReturnsOnCall map[int]struct {
		result1 error
	}
	GetMemberStub        func(signaling.PeerID) signaling.GroupMember
	getMemberMutex       sync.RWMutex
	getMemberArgsForCall []struct {
		arg1 signaling.PeerID
	}
	getMemberReturns struct {
		result1 signaling.GroupMember
	}
	getMemberReturnsOnCall map[int]struct {
		result1 signaling.GroupMember
	}
	IDStub        func() signaling.GroupID
	iDMutex       sync.RWMutex
	iDArgsForCall []struct {
	}
	iDReturns struct {
		result1 signaling.GroupID
	}
	iDReturnsOnCall map[int]struct {
		result1 signaling.GroupID
	}
	MessageMemberStub        func(signaling.Message) error
	messageMemberMutex       sync.RWMutex
	messageMemberArgsForCall []struct {
		arg1 signaling.Message
	}
	messageMemberReturns struct {
		result1 error
	}
	messageMemberReturnsOnCall map[int]struct {
		result1 error
	}
	PruneStaleMembersStub        func()
	pruneStaleMembersMutex       sync.RWMutex
	pruneStaleMembersArgsForCall []struct {
	}
	RemoveMemberStub        func(signaling.GroupMember)
	removeMemberMutex       sync.RWMutex
	removeMemberArgsForCall []struct {
		arg1 signaling.GroupMember
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeRoomGroup) AddMember(arg1 signaling.GroupMember) {
	fake.addMemberMutex.Lock()
	fake.addMemberArgsForCall = append(fake.addMemberArgsForCall, struct {
		arg1 signaling.GroupMember
	}{arg1})
	fake.recordInvocation("AddMember", []interface{}{arg1})
	fake.addMemberMutex.Unlock()
	if fake.AddMemberStub != nil {
		fake.AddMemberStub(arg1)
	}
}

func (fake *FakeRoomGroup) AddMemberCallCount() int {
	fake.addMemberMutex.RLock()
	defer fake.addMemberMutex.RUnlock()
	return len(fake.addMemberArgsForCall)
}

func (fake *FakeRoomGroup) AddMemberCalls(stub func(signaling.GroupMember)) {
	fake.addMemberMutex.Lock()
	defer fake.addMemberMutex.Unlock()
	fake.AddMemberStub = stub
}

func (fake *FakeRoomGroup) AddMemberArgsForCall(i int) signaling.GroupMember {
	fake.addMemberMutex.RLock()
	defer fake.addMemberMutex.RUnlock()
	argsForCall := fake.addMemberArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRoomGroup) Broadcast(arg1 signaling.Message) error {
	fake.broadcastMutex.Lock()
	ret, specificReturn := fake.broadcastReturnsOnCall[len(fake.broadcastArgsForCall)]
	fake.broadcastArgsForCall = append(fake.broadcastArgsForCall, struct {
		arg1 signaling.Message
	}{arg1})
	fake.recordInvocation("Broadcast", []interface{}{arg1})
	fake.broadcastMutex.Unlock()
	if fake.BroadcastStub != nil {
		return fake.BroadcastStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.broadcastReturns
	return fakeReturns.result1
}

func (fake *FakeRoomGroup) BroadcastCallCount() int {
	fake.broadcastMutex.RLock()
	defer fake.broadcastMutex.RUnlock()
	return len(fake.broadcastArgsForCall)
}

func (fake *FakeRoomGroup) BroadcastCalls(stub func(signaling.Message) error) {
	fake.broadcastMutex.Lock()
	defer fake.broadcastMutex.Unlock()
	fake.BroadcastStub = stub
}

func (fake *FakeRoomGroup) BroadcastArgsForCall(i int) signaling.Message {
	fake.broadcastMutex.RLock()
	defer fake.broadcastMutex.RUnlock()
	argsForCall := fake.broadcastArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRoomGroup) BroadcastReturns(result1 error) {
	fake.broadcastMutex.Lock()
	defer fake.broadcastMutex.Unlock()
	fake.BroadcastStub = nil
	fake.broadcastReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRoomGroup) BroadcastReturnsOnCall(i int, result1 error) {
	fake.broadcastMutex.Lock()
	defer fake.broadcastMutex.Unlock()
	fake.BroadcastStub = nil
	if fake.broadcastReturnsOnCall == nil {
		fake.broadcastReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.broadcastReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRoomGroup) GetMember(arg1 signaling.PeerID) signaling.GroupMember {
	fake.getMemberMutex.Lock()
	ret, specificReturn := fake.getMemberReturnsOnCall[len(fake.getMemberArgsForCall)]
	fake.getMemberArgsForCall = append(fake.getMemberArgsForCall, struct {
		arg1 signaling.PeerID
	}{arg1})
	fake.recordInvocation("GetMember", []interface{}{arg1})
	fake.getMemberMutex.Unlock()
	if fake.GetMemberStub != nil {
		return fake.GetMemberStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getMemberReturns
	return fakeReturns.result1
}

func (fake *FakeRoomGroup) GetMemberCallCount() int {
	fake.getMemberMutex.RLock()
	defer fake.getMemberMutex.RUnlock()
	return len(fake.getMemberArgsForCall)
}

func (fake *FakeRoomGroup) GetMemberCalls(stub func(signaling.PeerID) signaling.GroupMember) {
	fake.getMemberMutex.Lock()
	defer fake.getMemberMutex.Unlock()
	fake.GetMemberStub = stub
}

func (fake *FakeRoomGroup) GetMemberArgsForCall(i int) signaling.PeerID {
	fake.getMemberMutex.RLock()
	defer fake.getMemberMutex.RUnlock()
	argsForCall := fake.getMemberArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRoomGroup) GetMemberReturns(result1 signaling.GroupMember) {
	fake.getMemberMutex.Lock()
	defer fake.getMemberMutex.Unlock()
	fake.GetMemberStub = nil
	fake.getMemberReturns = struct {
		result1 signaling.GroupMember
	}{result1}
}

func (fake *FakeRoomGroup) GetMemberReturnsOnCall(i int, result1 signaling.GroupMember) {
	fake.getMemberMutex.Lock()
	defer fake.getMemberMutex.Unlock()
	fake.GetMemberStub = nil
	if fake.getMemberReturnsOnCall == nil {
		fake.getMemberReturnsOnCall = make(map[int]struct {
			result1 signaling.GroupMember
		})
	}
	fake.getMemberReturnsOnCall[i] = struct {
		result1 signaling.GroupMember
	}{result1}
}

func (fake *FakeRoomGroup) ID() signaling.GroupID {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct {
	}{})
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if fake.IDStub != nil {
		return fake.IDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.iDReturns
	return fakeReturns.result1
}

func (fake *FakeRoomGroup) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakeRoomGroup) IDCalls(stub func() signaling.GroupID) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = stub
}

func (fake *FakeRoomGroup) IDReturns(result1 signaling.GroupID) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 signaling.GroupID
	}{result1}
}

func (fake *FakeRoomGroup) IDReturnsOnCall(i int, result1 signaling.GroupID) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 signaling.GroupID
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 signaling.GroupID
	}{result1}
}

func (fake *FakeRoomGroup) MessageMember(arg1 signaling.Message) error {
	fake.messageMemberMutex.Lock()
	ret, specificReturn := fake.messageMemberReturnsOnCall[len(fake.messageMemberArgsForCall)]
	fake.messageMemberArgsForCall = append(fake.messageMemberArgsForCall, struct {
		arg1 signaling.Message
	}{arg1})
	fake.recordInvocation("MessageMember", []interface{}{arg1})
	fake.messageMemberMutex.Unlock()
	if fake.MessageMemberStub != nil {
		return fake.MessageMemberStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.messageMemberReturns
	return fakeReturns.result1
}

func (fake *FakeRoomGroup) MessageMemberCallCount() int {
	fake.messageMemberMutex.RLock()
	defer fake.messageMemberMutex.RUnlock()
	return len(fake.messageMemberArgsForCall)
}

func (fake *FakeRoomGroup) MessageMemberCalls(stub func(signaling.Message) error) {
	fake.messageMemberMutex.Lock()
	defer fake.messageMemberMutex.Unlock()
	fake.MessageMemberStub = stub
}

func (fake *FakeRoomGroup) MessageMemberArgsForCall(i int) signaling.Message {
	fake.messageMemberMutex.RLock()
	defer fake.messageMemberMutex.RUnlock()
	argsForCall := fake.messageMemberArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRoomGroup) MessageMemberReturns(result1 error) {
	fake.messageMemberMutex.Lock()
	defer fake.messageMemberMutex.Unlock()
	fake.MessageMemberStub = nil
	fake.messageMemberReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRoomGroup) MessageMemberReturnsOnCall(i int, result1 error) {
	fake.messageMemberMutex.Lock()
	defer fake.messageMemberMutex.Unlock()
	fake.MessageMemberStub = nil
	if fake.messageMemberReturnsOnCall == nil {
		fake.messageMemberReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.messageMemberReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRoomGroup) PruneStaleMembers() {
	fake.pruneStaleMembersMutex.Lock()
	fake.pruneStaleMembersArgsForCall = append(fake.pruneStaleMembersArgsForCall, struct {
	}{})
	fake.recordInvocation("PruneStaleMembers", []interface{}{})
	fake.pruneStaleMembersMutex.Unlock()
	if fake.PruneStaleMembersStub != nil {
		fake.PruneStaleMembersStub()
	}
}

func (fake *FakeRoomGroup) PruneStaleMembersCallCount() int {
	fake.pruneStaleMembersMutex.RLock()
	defer fake.pruneStaleMembersMutex.RUnlock()
	return len(fake.pruneStaleMembersArgsForCall)
}

func (fake *FakeRoomGroup) PruneStaleMembersCalls(stub func()) {
	fake.pruneStaleMembersMutex.Lock()
	defer fake.pruneStaleMembersMutex.Unlock()
	fake.PruneStaleMembersStub = stub
}

func (fake *FakeRoomGroup) RemoveMember(arg1 signaling.GroupMember) {
	fake.removeMemberMutex.Lock()
	fake.removeMemberArgsForCall = append(fake.removeMemberArgsForCall, struct {
		arg1 signaling.GroupMember
	}{arg1})
	fake.recordInvocation("RemoveMember", []interface{}{arg1})
	fake.removeMemberMutex.Unlock()
	if fake.RemoveMemberStub != nil {
		fake.RemoveMemberStub(arg1)
	}
}

func (fake *FakeRoomGroup) RemoveMemberCallCount() int {
	fake.removeMemberMutex.RLock()
	defer fake.removeMemberMutex.RUnlock()
	return len(fake.removeMemberArgsForCall)
}

func (fake *FakeRoomGroup) RemoveMemberCalls(stub func(signaling.GroupMember)) {
	fake.removeMemberMutex.Lock()
	defer fake.removeMemberMutex.Unlock()
	fake.RemoveMemberStub = stub
}

func (fake *FakeRoomGroup) RemoveMemberArgsForCall(i int) signaling.GroupMember {
	fake.removeMemberMutex.RLock()
	defer fake.removeMemberMutex.RUnlock()
	argsForCall := fake.removeMemberArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRoomGroup) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addMemberMutex.RLock()
	defer fake.addMemberMutex.RUnlock()
	fake.broadcastMutex.RLock()
	defer fake.broadcastMutex.RUnlock()
	fake.getMemberMutex.RLock()
	defer fake.getMemberMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.messageMemberMutex.RLock()
	defer fake.messageMemberMutex.RUnlock()
	fake.pruneStaleMembersMutex.RLock()
	defer fake.pruneStaleMembersMutex.RUnlock()
	fake.removeMemberMutex.RLock()
	defer fake.removeMemberMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeRoomGroup) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ signaling.RoomGroup = new(FakeRoomGroup)
